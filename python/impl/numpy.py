import dependency_manager
np = dependency_manager.dep('numpy')
import slm


ε = np.newaxis


'''
All the algorithms implementations are designed with the goal of having
the most primitive prototype possible.

# Data layout of spots
    * `soa`: assume the spots coordinates are in three separate vectors,
      namely `x`, `y`, and `z`
    * `aos`: assume the spots coordinates are in a single array of shape (#points, 3)
      this is present to mirror the C++ implementation

# Pupil
    * `pupil`: pupil coordinates could be computed a priori and read
    * `lazy`: or they can be generated by filtering

it's quite hard to express filtering in the array programming without first producing the pupil
coordinates (and thus falling back to the `pupil` case). I still keep this distinction to be
coherent with the C++ version

# Higher order functions
It is the job of the callers of these functions to provide the correct parameters so:
    * type
    * shape
    * dtype

GPU implementations need the arguments to be already allocated in GPU memory, otherwise profiling
is compromised. Wrapper functions could then profile the computation as the sequence of:
    memcpy(cpu -> device) + computation + memcpy(device -> gpu)

The glue code is yet to be written but it will have to solve the problem of minimizing the amount
of redundant arguments across devices and backends
'''
def rs_soa_pupil(x, y, z, xx, yy, C1, C2, pists) -> np.ndarray:
    return np.angle(
        np.mean(
            np.exp(
                1j * (
                    C1 * (x[:,ε]*xx[ε,:] + y[:,ε]*yy[ε,:]) +
                    C2 * z[:,ε] * (xx**2 + yy**2)[ε,:] +
                    2*np.pi*pists[:,ε]
                )
            ),
            axis=0
        )
    )


'''
It recomputes the `slm_p_phase` variable. I got to the conclusion that
this is the best choice given that memory accesses are generally slower
than computation.

    +-----------+---------------+--------------+
    |  policy   |   memory cost | compute cost |
    +-----------+---------------+--------------+
    | store     |    O(N*M)     |    O(1)      |
    | recompute |    O(N+M)     |   O(N*M)     |
    +-----------+---------------+--------------+
'''
def compute_metrics_soa_pupil(x, y, z, xx, yy, C1, C2, phase) -> slm.QualityMetrics:
    avg_spot_field = np.mean(
        np.exp(
            1j * (
                phase[ε,:] -
                C1 * (x[:,ε]*xx[ε,:] + y[:,ε]*yy[ε,:]) +
                C2 * z[:,ε] * (xx**2 + yy**2)[ε,:]
            )
        ),
        axis=1
    )

    intensity = np.abs(avg_spot_field)**2
    imin = np.min(intensity)
    imax = np.max(intensity)

    return slm.QualityMetrics(
        efficiency = np.sum(intensity),
        uniformity = 1 - (imax-imin)/(imax+imin),
        variance   = np.sqrt(np.var(intensity)) / np.mean(intensity)
    )
